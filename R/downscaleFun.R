
#' Downscale MODIS scene
#'
#' @param MOD MODIS scene in format raster, will be resampled to template resolution in case it is not already provided as such
#' @param aux auxiliary data in format raster stack as provided by package as aux.grd
#' @param ia incidence angle in format raster as generated by make_ia() 
#' @param template template in format raster as provided by package as template.grd
#' @param modname character, containing the first part of the MODIS scene name at least to derive whether the scene stems from Aqua or Terra satellite 
#' @param outformat default is ".grd" but could also be ".tif" 
#' @param add character, for an additional suffix to the outfile name in order to mark e.g. smaller extens
#' @return
#' downscaled MODIS LST at 30m resolution 
#' @export
#'
#' @examples

#' library(raster)
#' library(lubridate)
#' library(solrad)
#' library(downscaleLST.MDV)
#' 
#' 
#' exdate <- as.POSIXct("2018-11-12 13:50:00", tz="UTC")
#' ex2 <- raster::stack("inst/ex_2_all_layers.grd")
#' 
#' ##########  load the model ###############################################
#' load(system.file("final_model_downscaling_LST_MDV.RData", package = "downscaleLST.MDV"))
#' 
#' ##########  make ia and put into one stack  ###############################
#' ia_ex2 <- make_ia(M_date = exdate, outdir = here::here("ex_output"),
#'                      sl=ex2$slope, as=ex2$aspect, tmplt=ex2$template)
#' names(ia_ex2) <- "ia"
#' ex2_ia <- raster::stack(ex2, ia_ex2)
#' 
#' 
#' dsc_ex2 <- downscaleFun(MOD=ex2_ia$Mbilin,
#'                         aux=ex2_ia[[c( "dem","slope","aspect","soilraster","landcoverres")]],
#'                         ia=ex2_ia$ia, 
#'                         template=ex2_ia$template, 
#'                         modname="MYD11_L2.A2018316.1350.006",
#'                         outdir = "ex_output/",
#'                         writeRastertoOutdir = TRUE,
#'                         add="_ex2",
#'                         outformat=".grd")
#' 
#' comp_ex2 <- raster::stack(ex2$Mbilin, ex2$Mngb, dsc_ex2, ex2$L)
#' raster::writeRaster(comp_ex2, "inst/comp_ex2.grd",overwrite=T)
#' 
downscaleFun <- function(MOD, ia, modname, aux=aux, template=template,
                         writeRastertoOutdir=TRUE, outdir, add=NULL, outformat=".grd"){
  
      if(any(raster::res(MOD) != 30)){
        MOD <- resample(MOD, template, method="bilinear")
      }
      
      TeAqNum <- template
  
      if(grepl("MYD",modname)){
            TeAqNum[] <- 1
            # TeAqNum[1] <- 2
            # TA <- 1
            # corr <- 1
          } else {
            TeAqNum[] <- 2
            # TeAqNum[1] <- 1
            # TA = 2
            # corr <- 2
      
          }
      names(TeAqNum) <- "TeAqNum"
          
      
      # start putting a predictor stack together
      takeaux <- which(names(aux) %in% model_final$finalModel$xNames )
      aux <- aux[[takeaux]]
      names(aux)
      
      predstack <- raster::stack(MOD, aux, ia, TeAqNum)
      
      # prediction is performed on data.frame due to formatting in the model training data
      predstackdf <- data.frame(predstack[])
      predstackdf$soilraster <- factor(predstackdf$soilraster)
      predstackdf$TeAqNum <- factor(predstackdf$TeAqNum)
      predstackdf$landcoverres <- factor(predstackdf$landcoverres)
      names(predstackdf) <- c("Modis", names(predstackdf[2:length(names(predstackdf))]))
      predstackdf <- predstackdf[,model_final$finalModel$xNames] # order columns
      
      # bring new data into trainingData form
      trained_with <- model_final$trainingData[,1:(ncol(model_final$trainingData)-1)]
      if(any(!levels(predstackdf$soilraster)  %in% levels(trained_with$soilraster))){
        notintrainlevels <- levels(predstackdf$soilraster)[which(!levels(predstackdf$soilraster) %in% levels(trained_with$soilraster))]
        remove <- predstackdf$soilraster[predstackdf$soilraster %in% notintrainlevels]
        predstackdf$soilraster[predstackdf$soilraster %in% notintrainlevels] <- NA
        predstackdf$soilraster <- droplevels(predstackdf$soilraster)
        print(levels(predstackdf$soilraster))
        print("because these soil factor levels were not within the training boundaries, the following samples will be set to NA")
        print(table(droplevels(remove)))
      }
      
      compcaseloc <- which(complete.cases(predstackdf))
      predstackdf_comp <- predstackdf[complete.cases(predstackdf),]
      

      # to equalize classes of training and test set as suggested in  https://stackoverflow.com/questions/24829674/r-random-forest-error-type-of-predictors-in-new-data-do-not-match 
      predstackdf_comp <- rbind(trained_with[1, ] , predstackdf_comp)
      predstackdf_comp <- predstackdf_comp[-1,]

      pred <- predict(model_final, predstackdf_comp)
      
      allpix <- predstack$TeAqNum[]
      allpix <- NA
      allpix[compcaseloc] <- pred
      
      pred <- predstack$dem
      names(pred) <- "downscaled"
      pred[] <- allpix
      
      if(writeRastertoOutdir==TRUE){
              raster::writeRaster(pred, paste0(outdir, "dsc_", modname, add, outformat),
                          overwrite=T)
      }
      return(pred)
}


